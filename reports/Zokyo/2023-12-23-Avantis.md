**Auditors**

[Zokyo](https://x.com/zokyo_io)

# Findings

## High Risk

### Tranche’s withdrawal fees are not deducted properly

**Severity**: High

**Status**: Acknowledged

**Description**

In Contract Tranche.sol, methods redeem/withdraw calls _withdraw(...) method internally. The method _withdraw has the following logic:

```solidity
   function _withdraw(
       address caller,
       address receiver,
       address owner,
       uint256 assets,
       uint256 shares
   ) internal virtual override {
       require(
           utilizationRatio() < withdrawThreshold,
           "UTILIZATION_RATIO_MAX"
       );


       uint256 fee = getWithdrawalFeesRaw(assets);


       super._withdraw(caller, receiver, owner, assets, shares);


       if (fee > 0) {
           SafeERC20.safeTransfer(ERC20(asset()), address(vaultManager), fee);
           vaultManager.allocateRewards(fee);
       }
 … }

```
Here, the fee is calculated but the whole amount of `assets` is sent to the receiver address without the fee deduction. 
Instead, it is sent from the vault to the vault manager in the next line which is an extra amount being paid as a fee. 

**PoC:**


```solidity
   function testWithdrawalFee() public {
       uint rand = uint(keccak256(abi.encodePacked(block.timestamp))) %
           numTraders;
       address ownerTrader = traders[rand];
       vm.startPrank(ownerTrader);
       uint amountDeposited = usdc.balanceOf(ownerTrader);
       usdc.approve(address(juniorTranche), amountDeposited);


       emit log_named_uint("usdc amount deposited", amountDeposited);
       juniorTranche.deposit(amountDeposited, ownerTrader);


       emit log_named_uint(
           "minted shares",
           juniorTranche.balanceOf(ownerTrader)
       );


       uint withdrawalFeeRaw = juniorTranche.getWithdrawalFeesRaw(
           juniorTranche.balanceOf(ownerTrader)
       );
       emit log_named_uint("withdraw fee raw", withdrawalFeeRaw);


       emit log_named_uint(
           "withdraw fee total",
           juniorTranche.getWithdrawalFeesTotal(
               juniorTranche.balanceOf(ownerTrader)
           )
       );


       uint redeemB = juniorTranche.redeem(
           juniorTranche.balanceOf(ownerTrader),
           ownerTrader,
           ownerTrader
       );


       emit log_named_uint("redeem return assets", redeemB);


       emit log_named_uint(
           "usdc balance after redeem for owner",
           usdc.balanceOf(ownerTrader)
       );


       emit log_named_uint(
           "lp shares for owner",
           juniorTranche.balanceOf(ownerTrader)
       );


       assertEq(
           usdc.balanceOf(ownerTrader),
           amountDeposited - withdrawalFeeRaw
       );
   }
```


This test returns the following log:


**Recommendation**: 

update the logic to send `assets-fee` to the receiver during withdrawal.

```solidity


       super._withdraw(caller, receiver, owner, assets-fee, shares);

```

**Fix**: The client acknowledged the issue with the comment “While it looks like the fee is not being deducted, the fee will be shown on the UI as something the user has to pay on top of the assets they deposit”. 




### Lack of access control in `setWithdrawThreshold` function

**Severity**: High

**Status**: Resolved

**Description**

The `setWithdrawThreshold` function from Tranche contract  is responsible for setting a threshold that dictates the conditions under which withdrawals can occur from the contract. However, the function can be invoked by any external actor without restriction. A malicious actor could set the withdrawal threshold to a zero value, effectively freezing the contract's funds by making the utilization ratio limit unachievable. Setting it to zero would mean users could never meet the withdrawal criteria, effectively preventing all users from retrieving their assets.

**Recommendation**: 

Use an onlyGov modifier similar to that used for other governance functions.

## Medium Risk

### Possibility of immediate position liquidation after contract state is unpaused

**Severity**: Medium

**Status**: Acknowledged

**Description**

When the updateMargin function within Trading contract is paused, traders are unable to adjust their margins to respond to market volatility. If the market moves against a trader's position during the pause, they could fall below the required maintenance margin without any recourse to rectify the situation by depositing additional collateral. Consequently, once the contract resumes and updateMargin is re-enabled, these under-margined positions become immediate targets for liquidation bots.

**Recommendation**: 

Consider introducing a grace period after resuming contract functions to allow traders to update their margins before any liquidations can be processed.


### `PrincipalShareDeposited` is being increased without actual transfer/minting of shares 

**Severity**: Medium

**Status**: Resolved

**Description**

In Contract Tranche.sol, the method _withdraw(...) has the following logic:


```solidity
   function _withdraw(
       address caller,
       address receiver,
       address owner,
       uint256 assets,
       uint256 shares
   ) internal virtual override {
     . . .
       super._withdraw(caller, receiver, owner, assets, shares);


       if (fee > 0) {
           SafeERC20.safeTransfer(ERC20(asset()), address(vaultManager), fee);
           vaultManager.allocateRewards(fee);
       }


       // use original asset / share ratio and subject the relative asset amount
       if (receiver != owner) {
           _updateNegativePrincipal(owner, shares);


           // gifts are treated as deposits
           principalAssetsDeposited[receiver] += (assets - fee) * _PRECISION;
           totalPrincipalDeposited += (assets - fee) * _PRECISION;
           principalSharesDeposited[receiver] += shares;
       } else if (principalSharesDeposited[receiver] > 0) {
           _updateNegativePrincipal(receiver, shares);
       }
   }

```

Here, when receiver != owner, the mapping principalShareDeposited and principalAssetsDeposited are being increased for the receiver address after the shares of the owner have been burned and assets have been sent to the receiver address. 

This is confusing since there are no shares/LP tokens transferred to the receiver address but according to the mapping principalShareDeposited, the receiver owns some shares.

This is also contrary to the _deposit() method where actual shares are minted and also in _transfer() where shares are transferred from owner to receiver.
**PoC**:


```solidity
   function testReedem() public {
       uint rand = uint(keccak256(abi.encodePacked(block.timestamp))) %
           numTraders;
       address ownerTrader = traders[rand];
       vm.startPrank(ownerTrader);
       uint amount = usdc.balanceOf(ownerTrader);
       usdc.approve(address(juniorTranche), amount);


       emit log_named_uint("usdc amount deposited", amount);
       juniorTranche.deposit(amount, ownerTrader);


       emit log_named_uint(
           "minted shares",
           juniorTranche.balanceOf(ownerTrader)
       );


       address receiverTrader = makeAddr("receiver");
       uint redeemB = juniorTranche.redeem(
           juniorTranche.balanceOf(ownerTrader),
           receiverTrader,
           ownerTrader
       );


       emit log_named_uint("redeem return assets", redeemB);


       emit log_named_uint(
           "usdc balance after redeem for owner",
           usdc.balanceOf(ownerTrader)
       );


       emit log_named_uint(
           "lp shares for owner",
           juniorTranche.balanceOf(ownerTrader)
       );


       emit log_named_uint(
           "asset deposited  for owner",
           juniorTranche.principalAssetsDeposited((ownerTrader))
       );


       emit log_named_uint(
           "shares deposited for owner",
           juniorTranche.principalSharesDeposited((ownerTrader))
       );


       emit log_named_uint(
           "usdc balance after redeem for receiver",
           usdc.balanceOf(receiverTrader)
       );


       emit log_named_uint(
           "lp shares for receiver",
           (juniorTranche.balanceOf(receiverTrader))
       );


       emit log_named_uint(
           "asset deposited  for receiver",
           juniorTranche.principalAssetsDeposited((receiverTrader))
       );


       emit log_named_uint(
           "shares deposited for receiver",
           juniorTranche.principalSharesDeposited((receiverTrader))
       );


       }
```


This test logs the following result:


Here, we can see the receiver LP shares are 0 but shares deposited for the receiver are > 0.
It gives the false implication that the receiver has shares that can be withdrawn for assets but it will fail.

**Recommendation**: 

Update the _withdraw logic to avoid a misleading scenario to maintain consistency between real shares balance and mapping principalSharesDeposited.

**Fix**: Issue fixed, It is advised to remove the unused mappings principalAssetsDeposited & principalSharesDeposited.

### Method `getEarnings()` underflows

**Severity**: Medium

**Status**: Resolved

**Description**

As we notice in the above findings, the principalAssetDeposited is being increased for a receiver who has 0 LP tokens or no shares. The method getEarning(...) returns an unexpected result if it is checked for the same receiver.

**PoC**:

```solidity

   function testGetEarnings() public {
       uint rand = uint(keccak256(abi.encodePacked(block.timestamp))) %
           numTraders;
       address ownerTrader = traders[rand];
       vm.startPrank(ownerTrader);
       uint amount = usdc.balanceOf(ownerTrader);
       usdc.approve(address(juniorTranche), amount);


       emit log_named_uint("usdc amount deposited", amount);
       juniorTranche.deposit(amount, ownerTrader);


       emit log_named_uint(
           "minted shares",
           juniorTranche.balanceOf(ownerTrader)
       );
       address receiverTrader = makeAddr("receiver");


       emit log_named_uint(
           "earning for receiver before redeem",
           uint256(juniorTranche.getEarnings(receiverTrader))
       );
       uint redeemB = juniorTranche.redeem(
           juniorTranche.balanceOf(ownerTrader),
           receiverTrader,
           ownerTrader
       );


       emit log_named_uint("redeem return assets", redeemB);
       emit log_named_uint(
           "usdc balance after redeem for receiver",
           usdc.balanceOf(receiverTrader)
       );


       emit log_named_uint(
           "lp shares for receiver",
           (juniorTranche.balanceOf(receiverTrader))
       );
       emit log_named_uint(
           "earning for receiver after redeem",
           uint256(juniorTranche.getEarnings(receiverTrader))
       );
   }

```

This test logs the following results: 



Here, the earnings for the receiver after redemption is a very large value which is clearly due to underflow.

**Recommendation**: 

Update the `_withdraw` logic to avoid a misleading scenario to maintain consistency between real shares balance and mapping principalAssetsDeposited.


### Possibility of ETH being stuck in Trading contract

**Severity**: Medium

**Status**: Acknowledged

**Description**

In Contract Trading.sol, the methods updateSl(...) and updateTpAndSl(...) allows users to update the SL of an open trade. These methods internally call the _updateSl(...) method which has the following check.

```solidity

       if (
           _newSl == 0 ||
           !aggregator.pairsStorage().guaranteedSlEnabled(_pairIndex)
       ) {
           storageT.updateSl(msg.sender, _pairIndex, _index, _newSl);
           emit SlUpdated(
               msg.sender,
               _pairIndex,
               _index,
               _newSl,
               block.timestamp
           );
       } else {
		.
		.
		aggregator.fulfill{value: msg.value}(orderId, priceUpdateData);
	}

```
In this logic, `msg.value` passed as a fee for the fulfill(...) method is used only in the `else` branch. Otherwise, it is just kept in the contract and never used.

**Recommendation**: 

Add a method to withdraw the stuck ETH in case. Also, check off-chain if the contract has ETH already for the oracle fee and send accordingly.



### Function returns wrong values

**Severity**: Medium

**Status**: Resolved

**Description**

Referral.sol - Function traderReferralDiscount() returns significant false values of traderFeesPostDiscount and rebateShare.
That takes place in a scenario where tiers[_tierId].feeDiscountPct is zero. In that case traderFeesPostDiscount should be equal to _fee because there is zero discount. And so rebateShare should be non-zero since it is derived from traderFeesPostDiscount.

**Recommendation** 

Return the correct values in the case of zero `tiers[_tierId].feeDiscountPct`.

**Fix**:  Issue was addressed successfullthe y by client in dad4a2c6e161294019e0fd1ea7a89e797647c2e5  by removing the if statement.

### Potentially losing eth

**Severity**: Medium

**Status**: Acknowledged

**Description**

Trading.sol - Function openTrade accepts native coin (i.e. ETH in Ethereum main net) as it is payable function. Users interacting with this function might send native coin by mistake while the _type is not equal to IExecute.OpenLimitOrderType.MARKET. Therefore the contract is expecting USDC instead of native coin. In that scenario the coin sent is being wasted in the contract and not returned to the caller.
**Recommendation** 

Revert if msg.value is non-zero for the unexpected _type.
**Fix**:  While issue persists, it is acknowledged by client. It becomes a design choice which aims at saving the gas cost that comes with the required extra checks. That extra gas cost would be incurred by traders in most cases in order to protect careless traders in rare occasions, hence the choice to keep that code as it is. 

### Chainlink’s `latestRoundData` might return stale or incorrect results

**Severity**: Medium

**Status**:  Resolved

**Description**
 
The fulfill function in the PriceAggregator contract use Chainlink oracle as a second oracle to retrieve price data by calling latestRoundData. However, there's a risk that this data may be stale or incorrect due to various reasons related to Chainlink oracles. There is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation:
https://docs.chain.link/docs/historical-price-data/#historical-rounds

**Recommendation**: 

Check the updatedAt parameter returned from latestRoundData() and compare it to a staleness threshold. 

## Low Risk

### Instant governance transfer

**Severity**: Low

**Status**: Resolved
 
Contracts TradingStorage.sol, Referral.sol, Vester.sol, VaultManager.sol use setGov function for transferring ownership. In case of a mistake in the provided address, the management of the particular contract will be irretrievably lost.

**Recommendation**: 

Modify the process of updating the governance to be a two-step process. This will require the new owner to explicitly accept the ownership update.


### Function is returning the wrong first empty index

**Severity**: Low

**Status**: Resolved

**Description**

TradingStorage.sol - Function firstEmptyTradeIndex() mistakenly returns index = 0 since this is the default value to be returned. This takes place when the _openTrades array is filled as the loop surpasses maxTradesPerPair iterations and spits out the default return value zero.
```solidity
   function firstEmptyTradeIndex(address trader, uint pairIndex) public view override returns (uint index) {
        for (uint i = 0; i < maxTradesPerPair; i++) {
            if (_openTrades[trader][pairIndex][i].leverage == 0) {
                index = i;
                break;
            }
        }
    }
```
It also takes place here:
```solidity
   function firstEmptyOpenLimitIndex(address trader, uint pairIndex) public view override returns (uint index) {
        for (uint i = 0; i < maxTradesPerPair; i++) {
            if (!hasOpenLimitOrder(trader, pairIndex, i)) {
                index = i;
                break;
            }
        }
    }
```
The severity of the bug could have been more serious if Trading.openTrade() does not validate the count of trades being executed by the trader. Fortunately, there is a check to prevent that in Trading.openTrade() which overcomes that bug:

```solidity
252     require(
253         storageT.openTradesCount(msg.sender, t.pairIndex) +
254             storageT.pendingMarketOpenCount(msg.sender, t.pairIndex) +
255             storageT.openLimitOrdersCount(msg.sender, t.pairIndex) <
256             storageT.maxTradesPerPair(),
257         "MAX_TRADES_PER_PAIR"
258     );
```
This bug though is having affecting Multicall.getFirstEmptyTradeIndexes() since it also would return false zeroes.

**Recommendation** 

Function better reverts if there is no empty index (i.e. runover the for loop).

### Tranche Transfer can potentially lead to wasted assets

**Severity**: Low

**Status**: Resolved

Tranche.sol - function _transfer() does not assert that sender and recipient are not the same address. While this is not an issue in standard ERC20 since it does not leave side effects. It poses a potential issue in this case since the transfer to same address leaves a side effect due to _updateNegativePrincipal().

**Recommendation** 

Transferring to the same address needs to be disallowed.

**Fix**:  

Due to a big change in the implementation of the function, the issue becomes no longer relevant.

### `collateralFees` are initialized to values in a descending order

**Severity**: Low

**Status**: Resolved

**Description**

VaultManager.sol - collateralFees is initialized to an array of numbers that are arranged in a descending order.
collateralFees = [250, 150, 100, 25, 10];

Despite that setCollateralFees implementation requires that elements of array be arranged in an ascending order as shown here:
require(_collateralFees[i] < _collateralFees[i + 1], "NOT_DESCENDING_ORDER");

**Recommendation** 

Rearrange the values of collateralFees that are assigned on initialization.

### Referrer codes of user can be overridden and lost

**Severity**: Low

**Status**: Resolved

**Description**

Referral.sol - In registerCode() the mapping codes[msg.sender] can be overridden by a new _code on each time the sender invokes this function.
```solidity
   function registerCode(bytes32 _code) external {
        require(_code != bytes32(0), "ReferralStorage: invalid _code");
        require(codeOwners[_code] == address(0), "ReferralStorage: code already exists");

        codeOwners[_code] = msg.sender;
        codes[msg.sender] =  _code;
        referrerTiers[msg.sender] = _DEFAULT_TIER_ID;

        emit RegisterCode(msg.sender, _code);
    }
```
The issue arises in functions setCodeOwner(), govSetCodeOwner() as well. It overrides any code that might be already registered by the address of _newAccount.
```solidity
   function setCodeOwner(bytes32 _code, address _newAccount) external {
        require(_code != bytes32(0), "ReferralStorage: invalid _code");

        address account = codeOwners[_code];
        require(msg.sender == account, "ReferralStorage: forbidden");

        codeOwners[_code] = _newAccount;

        delete codes[account];
        codes[_newAccount] = _code;

        emit SetCodeOwner(msg.sender, _newAccount, _code);
    }

    function govSetCodeOwner(bytes32 _code, address _newAccount) external override onlyGov {
        require(_code != bytes32(0), "ReferralStorage: invalid _code");

        address account = codeOwners[_code];
        delete codes[account];

        codeOwners[_code] = _newAccount;
        codes[_newAccount] = _code;

        emit GovSetCodeOwner(_code, _newAccount);
    }
```
**Recommendation** 

Validate that the new account is not affiliated with any code before the transfer of code ownership takes place. 
**Fix**: The issue still persists, with a change of which function contains the issue: 

setCodeOwner()   ->  setPendingCodeOwnershipTransfer()
govSetCodeOwner  unchanged 


### ERC20 Transfers go unvalidated

**Severity**: Low

**Status**: Resolved

**Description**

In TradingStorage.sol - function `transferUSDC()` does not validate the returned bools of the ERC20 transfers. So in `handleDevGovFees`, `claimFees` and `claimRebate`.
Also in VaultManager.sol - function allocateRewards():

IERC20(junior.asset()).transferFrom(msg.sender, address(this), rewards)

as well as in function sendReferrerRebateToStorage()
IERC20(junior.asset()).transfer(address(storageT), _amount);

as well as in function _distributeVeRewards()
IERC20(junior.asset()).transfer(address(veTranche), rewards);

as well as in function _distributeRewards()
IERC20(junior.asset()).transfer(tranche, rewards);

**Recommendation** 

Use SafeERC20

### Centralization risk in several methods

**Severity**: Low

**Status**: Acknowledged

**Description**

Across the protocol, several methods use the modifier onlyGov() which can be used to configure important parameters for the protocol such as Pyth oracles, backup oracles, etc.. But in the TradingStorage contract, gov is being set to the deployer address which is an EOA.

This risks the whole protocol being centralized and controlled by a single EOA.

**Recommendation** 

It is advised to decentralize the usage of these functions by using a multisig wallet with at least 2/3 or a 3/5 configuration of trusted users. Alternatively, a secure governance mechanism can be utilized for the same. 


### Missing `_disableInitializer()` implementation

**Severity**: Low

**Status**: Resolved

**Description**

The following contracts inherit the Intializable.sol and implement the initialize(...) method with the initializer modifier without disabling the initializers for the implementation contract as recommended by OpenZeppelin here.

Execute.sol
PairInfos.sol
PairStorage.sol
PriceAggregator.sol
Trading.sol
TradingCallbacks.sol
TradingStorage.sol
Tranche.sol
VaultManager.sol
VeTranche.sol

**Recommendation**: 

Disable the initializers for the implementation method as suggested by OpenZeppelin here.



### Missing initializing `PausableUpgradeable` contract 

**Severity**: Low

**Status**: Resolved

**Description**

In Contract Trading.sol, PausableUpgradeable is inherited but not initialized. 

**Recommendation**: 

Initialize the PausableUpgradeable in the initialize() method adding __Pausable_init().


### The trading contract doesn’t allow the removal of whitelisted addresses

**Severity**: Low

**Status**: Resolved

**Description**

In Contract Trading.sol, method addWhitelist(...) allows gov to whitelist any address for accessing all trading methods. But there is no method to remove this whitelisted address if it’s needed in the future or if any whitelisted address turns malicious.

**Recommendation**: 

Add a method to allow removing whitelisted addresses in the trading contract.





### `MinLockTime` should be less than `maxLockTime`

**Severity**: Low

**Status**: Resolved

**Description**

In Contract VaultManager.sol, the setMinLockTime(...) assigns a value to minLockTime but it is not checked to be less than maxLockTime. In case minLockTime is accidentally set to greater than maxLockTime, unexpected issues might be encountered.

**Recommendation**: 

Add a check to ensure minLockTime < maxLockTime.


### Method `forceUnlock(...)` might fail for blacklisted USDC addresses

**Severity**: Low

**Status**: Acknowledged

**Description**

In Contract VeTranche.sol, method lock() allows anyone to lock their LP tokens for a time period and get an NFT as a token receipt. 
In case users do not unlock their tokens after lock period is over, the Platform can force unlock by burning the NFT token and sending the locked LP tokens along with a reward paid in USDC.
Any malicious user can deposit a minimal amount of USDC to mint LP tokens and lock those tokens to get an NFT token and pass that NFT token to a blacklisted USDC address.

In case of a blacklisted address in the USDC contract, this sending of USDC rewards will fail and forceUnlock(...)  will fail to unlock the LP tokens probably locked forever unless the malicious user sends the NFT to another address.

**Recommendation**: 

Add a try/catch for the USDC rewards transfer in the claimRewards() method. 


### The in-memory value won’t be updated

**Severity**: Low

**Status**: Resolved

**Description**

The function updateSlCallback in the TradingCallback contract is intended to update a stop loss for a trading order. The issue here is that t is a memory variable, which means it only exists within the scope of the function call and is not stored on the blockchain. Therefore, updating t.timestamp has no effect on the persistent data. This line of code will only change the timestamp of the local copy of the trade data, not the version that is stored on-chain in storageT.

**Recommendation**: 

The function should modify a state variable (stored in storage) instead of a memory variable.

## Informational

### Lack of PausableUpgradable initialization

**Severity**: Informational

**Status**: Resolved

**Description**

The Trading contract derives from PausableUpgradeable, however, it fails to initialize the inherited features.


**Recommendation**: 

Initialize the PausableUpgradeable contract.


### Insufficient validation of max lock time

**Severity**: Informational

**Status**: Resolved

**Description**

The function `setMaxLockTime` in `VaultManager` is designed to set the maximum lock time for locking shares in the VeTranche contract. However, there is a lack of a check to ensure that the new maximum lock time (_maxLockTime) is always greater than the already defined minimum lock time (minLockTime).

**Recommendation**: 

Check if the new lock time is greater than minLockTime.

### Unused import

**Severity**: Informational

**Status**: Resolved

**Description**

In Contract TradingCallbacks, PausableUpgradeble is imported but never used.

In Contract  Tranche.sol, ReentrancyGuardUpgradeable is imported, inherited, and initialized but never used.

**Recommendation**: 

Remove unused imports.


### `Trade.index` is assigned twice

**Severity**: Informational

**Status**: Acknowledged

In Contract TradingStorage, the method storeTrade(...) assigns _trade.index the return of method firstEmptyTradeIndex(...).

Although, storeTrade() is being called by the method _registerTrade(...) in the Contract TradingCallbacks. The method _registerTrade() is also assigning trade.index using the same method firstEmptyTradeIndex(...).

The same applies to the method firstEmptyOpenLimitIndex(...) in Trading.sol and TradingStorage.sol contracts.

**Recommendation**: 

It is advised to check if the assigned trade.index passed to the storeTrade(...) method correct or not instead of reassigning it. Apply the same for firstEmptyOpenLimitIndex(...).


### Methods `applyReferralOpen()` and `applyReferralClose()` can be combined into a single method

**Severity**: Informational

**Status**: Resolved

**Description**

In Contract TradingStorage, the methods applyReferralOpen() and applyReferralClose() have the same logic with the only exception being the return parameters and their values. These methods can be combined as follows:
```solidity
function applyReferral(
	 bool open,
       address _trader,
       uint _fees,
       uint _leveragedPosition
   ) public override onlyTrading returns (uint, uint) {
       (
           uint traderFeePostDiscount,
           address referrer,
           uint referrerRebate
       ) = referral.traderReferralDiscount(_trader, _fees);


       if (referrer != address(0)) {
           rebates[referrer] += referrerRebate;
           emit TradeReferred(
               _trader,
               referrer,
               _leveragedPosition,
               traderFeePostDiscount,
               _fees - traderFeePostDiscount,
               referrerRebate
           );
		if(open) {
			return (traderFeePostDiscount - referrerRebate,0);
		}
		return (traderFeePostDiscount, referrerRebate);
         }
	if(open) {
       return (_fees,0);
}
return (_fees, referrerRebate);
   }
```

**Recommendation**:

Use the above method to combine applyReferralOpen() and applyReferralClose().



### Confusing method name

**Severity**: Informational

**Status**: Acknowledged

**Description**

In Contract VaultManager, the method _receiveUSDCFromTrader(...) is actually transferring the TradeStorage contract to the VaultManager contract but this method specifies it is from the trader. It is noted that the trader funds are first transferred to the storage contract and then to the vault manager but adding a comment to clarify it can be better.

**Recommendation**: 

Add a comment to explain why funds are being transferred from the storage contract rather than the trader as the method name mentions.


### Split `require` statement with multiple conditions

**Severity**: Informational

**Status**: Acknowledged

**Description**

In Contract PairInfos,  the method setPercentDepthArray(..) has a `require` statement which has multiple conditions. 

In Contract PairStorage, modifier groupOk(...) and feeOk(...) have a `require` statement which has multiple conditions. 

In Contract PriceAggregator, the method fullfill(...) has a `require` statement to check the price and conf. 

In Contract Trading, several methods have `require` statements with multiple conditions.

In Contract TradingCallbacks, method setFeeP has a `require` statement with multiple conditions.

**Recommendation**: 

Split the conditions in the `require` statements.

### Inverse `if-else` statements  that have a negation

**Severity**: Informational

**Status**: Resolved

**Description**

In contract PairInfo, the method lossProtectionTier(...) has a `if-else` statement 

```solidity
       if (!_trade.buy) {
          action1
       } else {
          action2
       }
```

Can be switched to save gas.
```solidity
 if (_trade.buy) {
          action2
       } else {
          action1
       }
```

### Use optimal `for loop`

**Severity**: Informational

**Status**: Resolved

**Description**

Across the protocol, use the for loop in an optimal way as follows:
```solidity
for (uint256 i; i < limit; ) {
    
    // inside the loop
    
    unchecked {
        ++i;
    }
}
```
Also, in the Vault Manager contract, `for` loop `++i` can be `unchecked { ++i;}

### Right Bitshift by 1 when need to divide by 2

**Severity**: Informational

**Status**: Resolved

**Description**

Across the protocol, there are occurrences of value being divided by 2. It can be made cheaper by right-shifting them by 1.

In Trading.sol, levPosUSDC/2 can be levPosUSDC >> 1.

In PriceAggregator, the method _median can be updated as follows:
```solidity
function _median(uint[] memory array) public pure returns (uint) {
       _sort(array, 0, array.length);
       return
          array.length & uint256(1) == 0
               ? ((array[(array.length >> 1) - 1] +
                   array[array.length >> 1]) >> 1)
               : array[array.length >> 1];
   }
```

### Using inline assembly for address(0) check is cheaper 

**Severity**: Informational

**Status**: Acknowledged

**Description**

Across the protocol, there are many parameters being checked if they are address(0) or not.
To reduce gas costs, we can use the following assembly code format.
```solidity
function checkOptimized(address _caller) public pure returns (bool) {
        assembly {
            if iszero(_caller) {
                mstore(0x00, 0x20)
                mstore(0x20, 0x0c)
                mstore(0x40, 0x5a65726f20416464726573730000000000000000000000000000000000000000) // load hex of "Zero Address" to memory
                revert(0x00, 0x60)
            }
        }
}
```

### Safemath unnecessary computation cost being incurred

**Severity**: Informational

**Status**: Acknowledged

**Description**

VaultManager.sol - i++ does not need to be safely computed.
```solidity
   function setCollateralFees(uint256[5] memory _collateralFees) external onlyGov {
        for (uint i = 0; i < _collateralFees.length; ) {
            require(_collateralFees[i] < 10000, "TOO_HIGH");
            if (i != _collateralFees.length - 1)
                require(_collateralFees[i] < _collateralFees[i + 1], "NOT_DESCENDING_ORDER");
            i++;
        }
        collateralFees = _collateralFees;
    }

    function setBufferThresholds(uint256[5] calldata _bufferThresholds) external onlyGov {
        for (uint i; i < _bufferThresholds.length; ) {
            if (i != _bufferThresholds.length - 1)
                require(_bufferThresholds[i] < _bufferThresholds[i + 1], "NOT_DESCENDING_ORDER");
            i++;
        }
        bufferThresholds = _bufferThresholds;
    }
```
Also there is totalRewards -= _amount; despite it is asserted before that totalRewards >= _amount.
```solidity
   function sendReferrerRebateToStorage(uint _amount) external override onlyCallbacks {
        require(_amount > 0, "NO_REWARDS_ALLOCATED");
        require(totalRewards >= _amount, "UNDERFLOW_DETECTED");

        totalRewards -= _amount;
        IERC20(junior.asset()).transfer(address(storageT), _amount);

        emit ReferralRebateAwarded(_amount);
    }
```
In Tranche.sol - totalReserved += amount; and totalReserved -= amount; can be unchecked safely.
```solidity
   /** 
     * @notice Reserve a specific amount of balance.
     * @param amount The amount to reserve.
     */
    function _reserveBalance(uint256 amount) internal {
        require(super.totalAssets() >= amount + totalReserved, "RESERVE_AMOUNT_EXCEEDS_AVAILABLE");
        totalReserved += amount;
        emit BalanceReserved(amount);
    }

    /** 
     * @notice Release a specific amount of reserved balance.
     * @param amount The amount to release from the reserve.
     */
    function _releaseBalance(uint256 amount) internal {
        require(totalReserved >= amount, "RELEASE_AMOUNT_EXCEEDS_AVAILABLE");
        totalReserved -= amount;
        emit BalanceReleased(amount);
    }
```
**Recommendation**

Wrap operations within unchecked as they are ensured priorly they are within the safe bounds.
**Fix**:  Despite that client carried out useful gas savings, the specific examples from the codebase mentioned here are not addressed but acknowledged.

### Percentage value needs to be properly bounded

**Severity**: Informational

**Status**: Acknowledged

**Description**

PairStorage.sol - In function updateLossProtectionMultiplier() , caller feeds the function by array _multiplierPercent and it is not being checked to be less than 100.
```solidity
222     require(_multiplierPercent[i] >= _MAX_LOSS_REBATE, "REBATE_EXCEEDS_MAX");
```
**Recommendation** 

add `require (_multiplierPercent[i] < 100)`.

### Redundant operation

**Severity**: Informational

**Status**: Acknowledged

**Description**

Trading.sol - Function openTrade on line 277 calls firstEmptyOpenLimitIndex() in order to get the first empty index to open an order. But it is worth noting that storeOpenLimitOrder() already carries out that operation in its implementation.
```solidity
       if (_type != IExecute.OpenLimitOrderType.MARKET) {
277         uint index = storageT.firstEmptyOpenLimitIndex(msg.sender, t.pairIndex);

            storageT.storeOpenLimitOrder(
                ITradingStorage.OpenLimitOrder(
                    msg.sender,
                    t.pairIndex,
283                 index,
```
**Recommendation** 

Omit line 277 since it is already being executed in the implementation of storeOpenLimitOrder().

### Redundant if statement

**Severity**: Informational

**Status**: Resolved

TradingCallbacks.sol - In function executeLimitCloseOrderCallback(), the condition v.reward > 0 is already being checked in the outer if-statement line 380.
```solidity
380         if (o.orderType != ITradingStorage.LimitOrder.LIQ && v.reward > 0) {
381             uint usdcSentToTrader = _unregisterTrade(
382                 t,
383                 v.profitP,
384                 v.posUSDC,
385                 v.reward,
386                 (v.posToken.mul(t.leverage) * aggregator.pairsStorage().pairCloseFeeP(t.pairIndex)) /
387                     100 /
388                     _PRECISION,
389                 i.lossProtection
390             );

392             if (v.reward > 0) {
                    executor.distributeReward(
                        IExecute.TriggeredLimitId(o.trader, o.pairIndex, o.index, o.orderType),
                        v.reward
                    );
                }
```
**Recommendation** 

No need to have the if-statement at line 392.

### Misleading revert messages

**Severity**: Informational

**Status**: Acknowledged

**Description**

VaultManager.sol - Functions setCollateralFees() and setBufferThresholds() show a misleading revert message. For instance the elements of _collateralFees array are supposed to go in an ascending order (i.e. inceasing in value). But the revert message presents NOT_DESCENDING_ORDER which implies that the array should be put in descending order.
```solidity
   function setCollateralFees(uint256[5] memory _collateralFees) external onlyGov {
        for (uint i = 0; i < _collateralFees.length; ) {
            require(_collateralFees[i] < 10000, "TOO_HIGH");
            if (i != _collateralFees.length - 1)
                require(_collateralFees[i] < _collateralFees[i + 1], "NOT_DESCENDING_ORDER");
            i++;
        }
        collateralFees = _collateralFees;
    }

    function setBufferThresholds(uint256[5] calldata _bufferThresholds) external onlyGov {
        for (uint i; i < _bufferThresholds.length; ) {
            if (i != _bufferThresholds.length - 1)
                require(_bufferThresholds[i] < _bufferThresholds[i + 1], "NOT_DESCENDING_ORDER");
            i++;
        }
        bufferThresholds = _bufferThresholds;
    }
```
**Recommendation** 

Correct the misleading revert message.

### Vague revert messages

**Severity**: Informational

**Status**: Acknowledged

**Description**

PriceAggregator.sol - In function fulfill(), there are two cases in which the transaction fails. If the backup price (extracted by backup feed) is not within the accepted bounds of the price, the transaction fails. The two cases resembles whether back price is greater than or less than the price. It can be more helpful if the revert message shows which of the two cases that this transaction has failed.
```solidity
                   if (bkPrice > price) {
                        require(
                            (((bkPrice - price) * 100 * _PRECISION) / price) <= backupFeed.maxDeviationP,
                            "BACKUP_DEVIATION_TOO_HIGH"
                        );
                    }
                    if (bkPrice < price) {
                        require(
                            (((price - bkPrice) * 100 * _PRECISION) / bkPrice) <= backupFeed.maxDeviationP,
                            "BACKUP_DEVIATION_TOO_HIGH"
                        );
                    }
```
**Recommendation** 

Edit the revert message so that it gives information to the reader whether the failure came in a state of bkPrice < price or bkPrice > price as it can be helpful.


### Repeated instruction

**Severity**: Informational

**Status**: Resolved

**Description**

VeTranche.sol - In functions unlock() and forceUnlock(), we have lockStartTimeByTokenId[tokenId] gets to be deleted twice.
```solidity
       delete tokensByTokenId[tokenId];
        delete rewardsByTokenId[tokenId];
        delete lockTimeByTokenId[tokenId];
        delete lockStartTimeByTokenId[tokenId];
        delete lockMultiplierByTokenId[tokenId];
        delete lockStartTimeByTokenId[tokenId];
```

**Recommendation** 

no need to repeat delete lockStartTimeByTokenId[tokenId]

### Pair delisted but not deleted

**Severity**: Informational

**Status**: Resolved

**Description**

PairStorage.sol - pairs[_pairIndex] is not deleted despite that it is effectively dereferenced here. Deleting that record should be useful to release storage being used.
```solidity
   function delistPair(
        uint _pairIndex
    ) external onlyGov {
        Pair storage p = pairs[_pairIndex];
        require(isPairListed[p.from][p.to], "PAIR_NOT_LISTED");
        
        isPairListed[p.from][p.to]= false;
        emit PairUpdated(_pairIndex);
    }
```
**Recommendation** 

delete pairs[_pairIndex]

 

